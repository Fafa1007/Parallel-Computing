## **Question 1**

Use a `foreach` loop to repeat 100 times:

-   generate a random sample from an exponential distribution with mean 1

-   calculate mean and variance

-   *row-bind* your results (`rbind`) (results = mean and variance).

```{r}
library(doParallel)

cores <- detectCores() - 1  # Use available cores minus 1
cl <- makeCluster(cores)
registerDoParallel(cl)


result <- matrix(nrow=0, ncol = 2)

# Put "combine = rbind"
system.time({
  results <- foreach(i= 1:100,.combine = rbind) %dopar% {
    y <- rexp(100, rate = 1)
    x_bar <- mean(y)
    s_square <- var(y)
    cbind(x_bar, s_square)
  }
})

results
```

\newpage

## **Question 2**

Use the `doParallel` package and `foreach` to bootstrap the median for the galaxies data (in library MASS).

If the `foreach` function needs access to data or a function from a certain package, this can be done by adding the `.packages='MASS'` (for example) argument.

How does processing time compare to that of serial processing? If each iterationâ€™s run time is small, relative to the amount of data that needs to be loaded and returned, parallel processing might not actually speed up the total run time. Bootstrapping is relatively small: draw a sample, calculate a statistic. It might only start making a difference if each chunk becomes large relatively to the overheads of data transfer. Experiment with this. Try doing 1000 bootstrap samples at a time instead of managing single bootstrap samples.

```{r}
library(doParallel)
library(MASS)

cores <- detectCores() - 1  # Use available cores minus 1
cl <- makeCluster(cores)
registerDoParallel(cl)

bootstrap_median <- function(dat, B){
  medians <- foreach(i = 1:B, .packages = 'MASS', .combine = c) %dopar%   {
    bootstrap <- sample(dat, size = length(dat), replace=TRUE)
    median(bootstrap)
  }
  return(medians)
}

system.time({
  bootstrap_median(galaxies, 1)
})

system.time({
  bootstrap_median(galaxies, 100)
})

system.time({
  bootstrap_median(galaxies, 10000)
})
```

\newpage

## **Question 3**

Estimate coverage of a percentile bootstrap confidence interval for the following scenario: sample of size 50 from an exponential distribution with mean 1.

```{r}
library(doParallel)

cores <- detectCores() - 1  # Use available cores minus 1
cl <- makeCluster(cores)
registerDoParallel(cl)

set.seed(123)

bootstrap_coverage <- function(B,N){
   true_mean <- 1 # for exponential distribution true mean is lamda / rate
  
  count <- foreach(i = 1:N, .combine="+") %dopar% {
    dat <- rexp(50, rate = 1)
    
    bootstrap_means <- replicate(B, mean(sample(dat,size=length(dat),replace = TRUE)))
    
    upper_ci <- as.numeric(quantile(bootstrap_means, 0.975))
    lower_ci <- as.numeric(quantile(bootstrap_means, 0.025))
    
    ifelse(true_mean > lower_ci & true_mean < upper_ci, 1, 0)
  }
  coverage <- count/N
  return(coverage)
}

B <- 50 # Number of bootstraps be task
N <- 10000 # Number of simulations
system.time(print(bootstrap_coverage( B, N))) # Coverage Probability (should be close to the 95%, our confidence interval )
```

\newpage

## **Question 4**

The package `iterators` provides several functions that can be used to create sequences for the `foreach` function. For example, the `irnorm` function creates an object that iterates over vectors of normally distributed random numbers. It is useful when you need to use random variables drawn from one distribution in an expression that is run in parallel.

In this exercise, use the `foreach` and `irnorm` functions to iterate over 3 vectors, each containing 5 random variables. Find the largest value in each vector, and print those largest values.

Before running the `foreach` function set the seed to 1234.

```{r}

set.seed(1234)

cores <- detectCores() - 1  # Use available cores minus 1
cl <- makeCluster(cores)
registerDoParallel(cl)


# Use foreach to find the maximum in each vector
system.time(
max_values <- foreach(i = 1:3, .combine = c) %dopar% {
  library(iterators)
  it <- irnorm(1, count=5)
  max(nextElem(it))  # Find max value in each vector
})
print(max_values)
```

\newpage

## **Question 5**

Compare run time between `parLapply`, `foreach` and `replicate` for the above problem.

```{r}
library(iterators)
library(doParallel)
set.seed(1234)

cores <- detectCores() - 1  # Use available cores minus 1
cl <- makeCluster(cores)
registerDoParallel(cl)

# Parallel Function
parallel_apply <-  function(i) {
  library(iterators)
  it <- irnorm(1, count=5)
  max(nextElem(it))
}


# Use foreach to find the maximum in each vector
foreach_func <- function(n){
  max_values <- foreach(i = 1:n, .combine = c) %dopar% {
  library(iterators)
  it <- irnorm(1, count=5)
  max(nextElem(it))
}}

# Use parLapply to find the maximum in each vector
parLapply_func <- function(n){
  max_values <- parLapply(cl, 1:n, parallel_apply)
}

# Use replicate to find the maximum in each vector
replicate_func <- function (n){
  max_values <- replicate(n,parallel_apply(i=n))
}
```

```{r}
print("10 iterations")
n <- 10
system.time(foreach_func(n))
system.time(parLapply_func(n))
system.time(replicate_func(n))
```

```{r}
print("100 iterations")
n <- 100
system.time(foreach_func(n))
system.time(parLapply_func(n))
system.time(replicate_func(n))
```

```{r}
print("1000 iterations")
n <- 1000
system.time(foreach_func(n))
system.time(parLapply_func(n))
system.time(replicate_func(n))
```

```{r}
print("10000 iterations")
n <- 100000
system.time(foreach_func(n))
system.time(parLapply_func(n))
system.time(replicate_func(n))
```
